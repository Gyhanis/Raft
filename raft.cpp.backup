#include <stdlib.h>
#include "def.h"
#include "log.h"
#include "socket.h"

#define ELECTION_TIMEOUT 5

namespace raft {
        enum Role {
                Follower, Candidate, Leader
        } role;

        enum MSG_TYPE {
                RequestVote, 
                RequestVoteRsp,
                AppendEntries,
                AppendEntriesRsp,
        };

        struct MSG_RAFT {
                MSG_TYPE type;
                int id;
                int term;
                union {
                        struct {
                                int prevLogIndex;
                                int prevLogTerm;
                                int leaderCommit;
                                int entryCnt;
                                int entries[0];
                        };
                        struct {
                                int term;
                                int success;
                        }
                        struct {
                                int lastLogIndex;
                                int lastLogTerm;
                        };
                        struct {
                                int term;
                                int voteGranted;
                        };
                }
        };

        int currentTerm = 0;
        int votedFor = -1;
        int data[4096];

        int raft_id;
        int commitIndex = 0;
        int lastApplied = 0;

        int nextIndex[NODE_CNT];
        int matchIndex[NODE_CNT];

        int raft_init(int id) {
                raft_id = id;
                int r = init_socket(id);
                if (r < 0) {
                        ERROR("raft_init: socket init failed\n");
                }
                role = follower;
        }

        int raft_vote_response(MSG_RAFT *msg) {
                MSG_RAFT msg;
                msg.term = currentTerm;
                if (msgr->term < currentTerm) {
                        msg.voteGranted = false;
                } else if (votedFor != -1 && votedFor != raft_id) {
                        msg.voteGranted = false;
                } else {
                        //TO-DO
                        msg.voteGranted = true;
                }
                return send(to, &msg, sizeof(msg));
        }

        void raft_follower() {
                MSG msg;
                MSG_RAFT *msgr = (MSG_RAFT*) msg.data;
                int r = recv(&msg); 
                if (r < 0) {
                        INFO("Heartbeat timeout, start election!");
                        currentTerm++;
                        role = Role::candidate;
                } else {
                        switch (msgr->type) {
                        MSG_TYPE::RequestVote:
                                raft_vote_response(msgr);
                                break;
                        MSG_TYPE::AppendEntries:
                                raft_append_response(msgr);
                                break;
                        default:
                                break;
                        }
                }
        }

        void raft_request_vote() {
                MSG_RAFT msg;
                msg.type = MSG_TYPE::RequestVote;
                msg.term = currentTerm;
                msg.id = raft_id;
                msg.lastLogIndex = 0;
                msg.lastLogTerm = 0;
                boardcast(&msg, sizeof(msg));
        }

        void raft_candidate() {
                votedFor = raft_id;
                raft_request_vote();
                set_timeout(ELECTION_TIMEOUT + rand() % NODE_CNT);
                while (1) {
                        MSG msg;
                        MSG_RAFT *msgr = (MSG_RAFT*) msg.data;
                        recv(&msg);
                        if (msgr->)
                }
        }

        int raft_loop() {
                while (1) {
                        switch (role) {
                        case Role::Follower: 
                                raft_follower();
                                break;
                        case Role::Candidate:
                                raft_candidate();
                                break;
                        case Role::Leader:
                                break;
                        }
                }
        }
}
